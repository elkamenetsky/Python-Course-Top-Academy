# Получение ключей и значений словаря через спец. функции

# d = {'a': 1, 'b': 2, 'c': 3}
# print(d['c'])
# value = d.get('f', 'Такого ключа нет')  # get получает значение по заданному ключу (в т.ч. по несуществующему)
# print(value)
# n = d.keys()  # получение списка ключей
# print(n)
# n = d.values()  # получение списка значений
# print(n)
# n = d.items()  # получение списка кортежей (ключ: значение)
# print(n)
#
# for i, j in d.items():  # получение ключей и значений через for
#     print(i, '->', j)


# Создание копии словаря

# d = {'a': 1, 'b': 2, 'c': 3}
# d2 = d
# print('D =', d)
# print('D2 =', d2)
# d['b'] = 5
# d2['e'] = 7
# # Отличий не будет, т.к. ссылаются на один id
# print('D =', d, id(d))
# print('D2 =', d2, id(d2))
#
# d2 = d.copy()  # Создание копии словаря
# d['b'] = 2
# d2['f'] = 4
# # Теперь отличия будут
# print('D =', d, id(d))
# print('D2 =', d2, id(d2))


# Удаление и возвращение через pop и popitem

# d = {'a': 1, 'b': 2, 'c': 3}
# item = d.pop('b')  # удаление и возвращение (возвращает только значение! не пару - ключ: значение)
# print(d)
# print(item)
# item = d.popitem()  # удаляет произвольную (последнюю) пару (ключ: значение)
# print(d)
# print(item)


# Метод setdefault (вывод / добавление нового)

# d = {'a': 1, 'b': 2, 'c': 3}
# item = d.setdefault('c')  # Вывод значения элемента
# print(d)
# print(item)
# item = d.setdefault('f', 5)  # Добавление ключа: значения, если его не существует (заменять не может)
# print(item)


# Добавление и перезапись элементов через метод update

# d = {'a': 1, 'b': 2, 'c': 3}
# d.update({'a': 20, 'w': 10})  # перезапись и добавление
# print(d)
# d.update([('q', 7), ('t', 6), ('e', 5)])  # добавление новых (списка кортежей, значения переданы в ключ: значение)
# print(d)


# Задача по объединению 2 словарей в новый словарь

# x = {'a': 1, 'b': 2}
# y = {'b': 3, 'c': 4}
# z = x.copy()
# z.update(y)
# print(z)
#
# z = x | y  # другой способ
# print(z)


# Задача с созданием словаря из части данных другого
# и удаление этих данных из изначального + переименование одного из ключей

# d = {'name': 'Kelly', 'age': 25, 'salary': 8000, 'city': 'New York'}
# d1 = dict()
# d1['name'] = d.pop('name')  # перенесли пару в другую переменную
# d1['salary'] = d.pop('salary')
# d['location'] = d.pop('city')  # изменили ключ
#
# print(d1)
# print(d)


# Визуальное форматирование

# a = {
#     'first': {
#         1: 'one',
#         2: 'two',
#         3: 'three'
#     },
#     'second': {
#         4: 'four',
#         5: 'five'
#     }
# }
# print(a)
#
# for x in a:
#     print(x)
#     for y in a[x]:
#         print('\t', y, ': ', a[x][y], sep='')


# Создание двумерного словаря и внесение новых значений с выводом части словаря

# sales = {
#     'John': {
#         'N': 3056, 'S': 8464, 'E': 8441, 'W': 2694
#     },
#     'Tom': {
#         'N': 4832, 'S': 4786, 'E': 4737, 'W': 3612
#     },
#     'Anne': {
#         'N': 5239, 'S': 4882, 'E': 5829, 'W': 1859
#     },
#     'Fiona': {
#         'N': 3984, 'S': 3645, 'E': 8821, 'W': 2451
#     }
# }
#
# for x in sales:
#     print(x)
#     for y in sales[x]:
#         print('\t', y, ': ', sales[x][y], sep='')
#
# person = input('Имя: ')
# region = input('Регион: ')
# new_data = int(input('Новое значение: '))
# sales[person][region] = new_data
#
# print(sales[person])


# Замена ключа и значения местами

# d = {'a': 1, 'b': 2, 'c': 3, 'd': 4}
# print({v: k for k, v in d.items()})


# Создание нового словаря из списка (в ключи) с вводом фиксированного значения

# value = int(input('-> '))
# lt = [7, 8, 9]
# d = {k: value for k in lt}  # lt - ключи, value - значение (одно у всех ключей)
# print(d)


# Преобразование словаря в список

# d = {'a': 1, 'b': 2, 'c': 3, 'd': 4}
# value = list(d)  # запишется список из ключей d
# print(value)
# value = list(d.items())  # запишется список из кортежей (ключей и значений)
# print(value)


# Задача: список -> словарь, чтобы строки - ключи, числа - значения

# a = ['one', 1, 2, 3, 'two', 10, 20, 'three', 15, 36, 60, 'four', -20]
# d = dict()
# s = None  # вспомогательная переменная
#
# for i in a:
#     if type(i) == str:
#         d[i] = []  # d['one'] = []
#         s = i  # s = 'one'
#     else:
#         d[s].append(i)  # d['two'] = [10, 20]
#
# print(d)
#
# ТАКОЙ ВАРИАНТ СРАБОТАЕТ ТОЛЬКО ЕСЛИ ПЕРВОЕ ЗНАЧЕНИЕ - СТРОКА !


# Создание словаря через dict(zip(ключ: значение))

# a = ['Dec', 'Jan', 'Feb']
# b = [12, 1, 2]
# d = dict(zip(a, b))  # zip объединяет 2 итерируемых объекта
# # Если элементов не одинаковое количество, то лишние будут просто отброшены
# print(d)
#
# b = [12, 1, 2]
# d = list(zip(b))  # ошибки не будет - будет список из 3 кортежей
# print(d)
#
# a = ['Dec', 'Jan', 'Feb']
# b = [12, 1, 2]
# c = [2.0, 4.6, 5.4]
# d = list(zip(a, b, c))  # можно и 3 элемента (НО не в словарь!)
# print(d)


# Параллельный вывод без объединения словарей через zip

# one = {'name': 'Igor', 'last_name': 'Doe', 'job': 'consultant'}
# two = {'name': 'Irina', 'last_name': 'Smith', 'job': 'manager'}
#
# for (k1, v1), (k2, v2) in zip(one.items(), two.items()):
#     print(k1, '->', v1)
#     print(k2, '->', v2)


# Распаковка через zip

# pairs = [(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')]
# a, b = zip(*pairs)  # получится 2 отдельных кортежа (с 0 индексом), (с 1 индексом)
# # * нужна, чтобы убрать наружное окружение [...]
# print(a)
# print(b)
#
# one = {'apple': 0.4, 'orange': 0.35}
# two = {'pepper': 0.2, 'onion': 0.55}
# # print(one | two)  # объединить можно так
# print({**one, **two})  # можно так (распаковка словаря - убрали фигурные скобки)


# Функция enumerate

# data = ['a', 'b', 'c', 'd']
#
# # for i in data:
# #     print(i, end=' ')
# # print()
# # for i in range(len(data)):
# #     print(i, end=' ')
# # print()
# #
# # j = 1
# # for i in data:
# #     print(j, ':', i)
# #     j += 1
#
# # enumerate - функция нумерации (объект, старт), j - значение для enumerate (без нее будет кортеж)
# for j, i in enumerate(data):  # то же самое, но более компактно
#     print(j, ':', i)
#
# d = {'a': 1, 'b': 2, 'c': 3, 'd': 4}
# for j, (i, v) in enumerate(d.items(), 100):
#     print(j, ':', i, '->', v)


# * и функции

# a = [1, 2, 3]
# b = [4, a, 5, 6]  # а как вложенный список внутри b
# print(b)
# b = [4, *a, 5, 6]  # сделали распаковку списка а
# print(b)


# def func(*args):  # * дает возможность в функции работать с любым количеством элементов
#     res = 0
#     for i in args:
#         res += i
#     return res
#     # return args
#
#
# print(func(3))  # так всё нормально (со * будет кортеж - с return args)
# # print(func(3, 4, 5))  # так будет ошибка (без *args)
# print(func(3, 4, 5))  # теперь нормально (поставили *)

